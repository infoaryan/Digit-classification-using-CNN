# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1e97_7so-XUrON8D5yYEBwNrppuLZwypv
"""

import numpy as np 
import keras  
from keras.datasets import mnist 
from keras.models import Model 
from keras.layers import Dense, Input
from keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten 
from keras import backend as k 

import matplotlib.pyplot as plt

#splitting the data into test and train portions
(x_train, y_train), (x_test, y_test) = mnist.load_data() 
#Getting the shapes of the dataset
print("Shape of x_train = "+str(x_train.shape))
print("Shape of y_train = "+str(y_train.shape))
print("Shape of x_test = "+str(x_test.shape))
print("Shape of y_test = "+str(y_test.shape))

#Size of the images in dataset
img_rows, img_cols=28, 28
#reshaping the images to include the channel in it
x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1) 
x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1) 
inpx = (img_rows, img_cols, 1) 
  
x_train = x_train.astype('float32') 
x_test = x_test.astype('float32') 
x_train /= 255
x_test /= 255

# plot images
num_row = 2
num_col = 5
fig, axes = plt.subplots(num_row, num_col, figsize=(1.5*num_col,2*num_row))
for i in range(10):
    ax = axes[i//num_col, i%num_col]
    ax.imshow(x_train[i].reshape(28,28), cmap='gray')
    ax.set_title('Label: {}'.format(y_train[i]))
plt.tight_layout()
plt.show()

# Now as this is multi class classification so we need to make the class variables
# hence, we need to categorize the labels

from keras.utils import to_categorical
num_classes = 10
y_train_categorized = to_categorical(y_train,num_classes)
y_test_categorized = to_categorical(y_test,num_classes)
y_train_categorized.shape, y_test_categorized.shape

# shuffle the training dataset (5 times!)
for _ in range(5): 
    indexes = np.random.permutation(len(x_train))

x_train = x_train[indexes]
y_train_categorized = y_train_categorized[indexes]

# now set-aside 10% of the train_data/labels as the
# cross-validation sets
val_perc = 0.10
val_count = int(val_perc * len(x_train))

# first pick validation set from train_data/labels
val_data = x_train[:val_count,:]
val_labels = y_train_categorized[:val_count,:]

# leave rest in training set
train_data = x_train[val_count:,:]
train_labels = y_train_categorized[val_count:,:]

#Finally training the model
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

def build_model():
    model = Sequential()
    # add Convolutional layers
    model.add(Conv2D(filters=32, kernel_size=(3,3), activation='relu', padding='same',
                     input_shape=(28,28,1)))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Conv2D(filters=64, kernel_size=(3,3), activation='relu', padding='same'))
    model.add(MaxPooling2D(pool_size=(2,2)))
    model.add(Conv2D(filters=64, kernel_size=(3,3), activation='relu', padding='same'))
    model.add(MaxPooling2D(pool_size=(2,2)))    
    model.add(Flatten())
    # Densely connected layers
    model.add(Dense(128, activation='relu'))
    # output layer
    model.add(Dense(10, activation='softmax'))
    # compile with adam optimizer & categorical_crossentropy loss function
    model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
    return model

model = build_model()
print(model.summary())

history = model.fit(train_data, train_labels, 
                    epochs=19, batch_size=64,
                    validation_data=(val_data, val_labels))

print(history.history.keys())

#  "Accuracy" plotting
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()
# "Loss" plotting
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()

test_loss, test_accuracy = model.evaluate(x_test, y_test_categorized, batch_size=64)
print('Test loss: %.4f accuracy: %.4f' % (test_loss, test_accuracy))

